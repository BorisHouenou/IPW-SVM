<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h1 id="using-inverse-probability-weighting-with-svms-to-address-confounding">Using Inverse Probability Weighting with SVMs to Address Confounding</h1>
<h3 id="by-kristin-a.-linn">by Kristin A. Linn</h3>
<h3 id="june-25-2015">June 25, 2015</h3>
<p>Here we provide an example of how to implement inverse probability weighting with SVMs to address confounding. The basic setup is that we have feature, class label pairs of the form <span class="math">(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>i</em></sub>)</span> for each subject, <span class="math"><em>i</em> = 1, …, <em>n</em></span>, where <span class="math"><em>y</em><sub><em>i</em></sub> ∈ {0, 1}</span> and <span class="math"><em>x</em><sub><em>i</em></sub> ∈ ℝ<sup><em>p</em></sup></span> for all <span class="math"><em>i</em></span>. We wish to train a SVM to predict <span class="math"><em>y</em></span> given <span class="math"><em>x</em></span>. As an example, <span class="math"><em>y</em></span> might be an indicator of disease/control group and <span class="math"><em>x</em></span> might be a vectorized image containing voxel values or volumes of regions across the brain. However, the additional feature vector <span class="math"><em>a</em><sub><em>i</em></sub> ∈ ℝ<sup><em>s</em></sup></span> observed for all subjects confounds the relationship between <span class="math"><em>x</em></span> and <span class="math"><em>y</em></span>. For example, <span class="math"><em>a</em></span> might contain covariates such as age and sex. In the presence of confounding by <span class="math"><em>a</em></span>, inverse probability weighting is used to recover an estimate of the target classifier, which is the SVM classifier that would have been estimated had there been no confounding by <span class="math"><em>a</em></span>.</p>
<pre class="{r}"><code>rm (list=ls())
set.seed (1)</code></pre>
<p>We use the package 'rPython' to access libSVM (https://www.csie.ntu.edu.tw/~cjlin/libsvm/) through scikit learn (http://scikit-learn.org/stable/). The file fit_svm.py contains a python function that implements a linear kernel SVM with subject-level weights and a grid search to tune the cost parameter, <span class="math"><em>C</em></span>.</p>
<pre class="{r}"><code>library(MASS)
library(rPython)
python.load(&quot;/Users/kalinn/GitHub/IPW-SVM/fit_svm.py&quot;)</code></pre>
<h2 id="generate-data-for-example">Generate data for example</h2>
<p>We generate data such that the confounders, a1 and a2, affect both the features, x1 and x2, as well as the class labels, d.</p>
<pre class="{r}"><code># Total in confounded sample
n = 200
# Number of noise features
k = 10
# a1 and a2 are confounders
a1 = runif (n, 0, 1)
a2 = rbinom(n, 1, .5)
# d is a vector of class labels
ld = -1 + a1 + a2 + rnorm(n, 0, .5)
d = 1*(exp(ld)/(1+exp(ld))&gt;.5)
# covariance structure for features
# x1 and x2 are  
covmat = matrix (c (2, .5, .5, 2), 2, 2)
errs = mvrnorm (n, mu=rep (0, 2), Sigma=covmat)
# x1 and x2 are features
x1mean = 5 - 2*d - .5*a1
x2mean = -3*a1 + .5*a2 - .5*d*(a1 + .5*a2 + .25*a1*a2) 
x1 = scale(x1mean + errs[,1])
x2 = scale(x2mean + errs[,2])
noise = matrix (rnorm(n*k), n, k)
features = data.frame(x1=x1, x2=x2, noise=noise)</code></pre>
<h2 id="estimate-the-inverse-probability-weights">Estimate the inverse probability weights</h2>
<p>Here, we estimate the weights by fitting a logistic regression of class (d) on confounders (a1 and a2). However, more flexible methods can be substituted here to obtain estimates of the weights. All that is needed is an estimate of <span class="math"><em>p</em><em>r</em>(<em>d</em><sub><em>i</em></sub> = 1 | <em>a</em>1<sub><em>i</em></sub>, <em>a</em>2<sub><em>i</em></sub>)</span> for each subject, <span class="math"><em>i</em> = 1, …, <em>n</em></span>.</p>
<pre class="{r}"><code># Fit the model
lr.fit = glm(d~a1+a2, family=binomial)
# Obtain predicted values of pr(d=1 | a1, a2) for each subject
lr.predict = lr.fit$fitted.values
# Obtain predicted probabilities of each subject&#39;s observed class given observed confounder values
lr.obs = lr.predict*d + (1-lr.predict)*(1-d)
# The inverse probability weights are the inverse of the former quantity
ipweights = 1/lr.obs
hist(ipweights)</code></pre>
<p>N.B. If some of the estimated weights are extremely large, one may consider truncating the predicted probabilities (e.g., at the 5th percentile) or using stabilized weights. Define <span class="math"><em>S</em><sub><em>i</em></sub> = <em>p</em><em>r</em>(<em>d</em><sub><em>i</em></sub> = 1 | <em>a</em>1<sub><em>i</em></sub>, <em>a</em>2<sub><em>i</em></sub>)</span> and <span class="math"><em>M</em><sub><em>i</em></sub> = <em>p</em><em>r</em>(<em>d</em><sub><em>i</em></sub> = 1)</span> as well as corresponding estimates <span class="math">$\hat{S}_{i} = \hat{\mbox{pr}}(d_{i}=1 \; | \; a1_{i}, a2_{i})$</span> and <span class="math">$\hat{M}_{i} = \hat{\mbox{pr}}(d_{i}=1)$</span>, Then, stabilized weights and their corresponding estimates are defined, respectively, as:</p>

<h2 id="train-the-inverse-probability-weighted-svm-ipw-svm">Train the inverse probability weighted SVM (IPW-SVM)</h2>
<pre class="{r}"><code># For tuning the cost parameter
cost = 10^c(-3:3)
# rPython needs a matrix with no column names
features = as.matrix(features)
colnames(features) = NULL
# rPython is picky about inputs!
ipweights = as.numeric (as.character (ipweights))
# Here we input the full data as both the training and test sets, but in a real application we might split the original data into training and validation sets or perform cross-validation.
train.svm = python.call(&quot;fit_ipw_svm&quot;, features, d, features, ipweights, cost)</code></pre>
<h2 id="return-parameters-of-interest">Return parameters of interest</h2>
<pre class="{r}"><code># IPW-SVM intercept of the linear decision rule
train.svm[[1]]
# IPW-SVM weights of the linear decision rule
train.svm[[2]]
# Class predictions for the test set
train.svm[[3]]</code></pre>
</body>
</html>
